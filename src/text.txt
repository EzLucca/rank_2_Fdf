/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fdf.h                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: edlucca <edlucca@student.hive.fi>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/03 10:40:18 by edlucca           #+#    #+#             */
/*   Updated: 2025/07/16 14:48:16 by edlucca          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FDF_H
# define FDF_H

# include <stdlib.h>
# include <errno.h>
# include <fcntl.h>
# include <math.h>
# include <string.h>
# include <limits.h>
# include <stdio.h>
# include <stdbool.h>
# include "../lib/libft/include/libft.h"
# include "../lib/MLX42/include/MLX42/MLX42.h"

# define BPP sizeof(int32_t)
# define WIDTH 1280 /* Initial window width */
# define HEIGHT 720 /* Initial window height */
# define TITLE "Fdf" /* Text shown in window title bar */
# define TEXT_COLOR			0xEAEAEAFF
# define BACKGROUND			0x22222200
# define MENU_BACKGROUND	0x1E1E1EFF
# define COLOR_TEN			0x9e0142ff
# define COLOR_NINE			0xd53e4fff
# define COLOR_EIGHT		0xf46d43ff
# define COLOR_SEVEN		0xfdae61ff
# define COLOR_SIX			0xfee08bff
# define COLOR_FIVE			0xe6f598ff
# define COLOR_FOUR			0xabdda4ff
# define COLOR_THREE		0x66c2a5ff
# define COLOR_TWO			0x3288bdff
# define COLOR_ONE			0x5e4fa2ff

typedef struct s_point3d
{
	double	x;
	double	y;
	double	z;
	int		mapcolor;
	int		zcolor;
} t_point3d;

typedef struct s_point2d
{
	int		x;
	int		y;
	int		z;
	int		rgba;
} t_point2d;

typedef struct s_map
{
	int				rows;
	int				cols;
	int				high;
	int				low;
	bool			use_zcolor;
	double			alpha;
	double			beta;
	double			interval;
	double			x_offset;
	double			y_offset;
	double			xrotate;
	double			yrotate;
	double			zrotate;
	double			zoom;
	double			zscale;
	t_point3d		**grid3d;
	t_point2d		**grid2d;
} t_map;

typedef struct s_fdf
{
	mlx_t		*mlx;
	t_map		*map;
	mlx_image_t	*image;
} t_fdf;

void	*free_array(char **array);

// rotations.c
void	rotate_x(double *y, double *z, double alpha);
void	rotate_y(double *x, double *z, double beta);
void	rotate_z(double *x, double *y, double gamma);

// parsing.c
int		ft_atoi_hex(const char *hex);
int		fill_color(char *data, t_map *map, int fd);
void	process_points(int fd, t_map *map, char *line, int y);
void	parse_map(int fd, t_map *map);
void	allocate_grid(t_map *map);

// main.c
void	grid_check(int fd, t_map *map);
void	init_map(t_map *map);
t_map	*open_validate_map(char *filename);
void	init_fdf(char *filename, t_fdf *fdf);

// checks.c
bool	color_check(const char *color);
bool	number_check(const char *str);
bool	valid_point(char *token);
bool	points_check(char *line);

// image.c
int		radiant(int begin, int end, double percent);
int		get_color(t_point2d current, t_point2d a, t_point2d b);
double	colormix(int begin, int end, int current);
int		colors(double percent);
void	set_zcolor(t_map *map);

// hook.c
void	ft_hook_project(void *param);
void	ft_hook_rotate(void *param);
void	ft_hook(void *param);
void	ft_scroll_hook(double xdelta, double ydelta, void *param);
void	resize_hook(int width, int height, void *param);

// loop.c
void	loop_mlx(t_fdf *fdf);
void	reset_map(t_map *map);
void	reset_draw(mlx_image_t *image);

// draw.c
void	bresenham_algo(mlx_image_t *image, t_point2d a, t_point2d b);
void	project_point(t_map *map, int y, int x);
void	draw_line(t_fdf *fdf, int x, int y);
void	draw_image(void *param);
void	display_menu(mlx_t *mlx);

// utils.c
void	ft_error(char *str);
void	ft_free_tab(void **tab, size_t len);
void	free_map(t_map *map);
void	ft_error_close(char *str, int fd);
void	ft_error_map(char *str, int fd, t_map *map);
void	ft_upper(unsigned int i, char *c);
// int		check_extension(char *filename);
#endif
==> checks.c <==

bool	color_check(const char *color)
{
	int i;

	if (!color)
		return (false);
	if (color[0] != '0' || color[1] != 'x')
		return (false);
	i = 2;
	if (color[i] == '\0')
		return (false);
	while (color[i])
	{
		if (!((color[i] >= '0' && color[i] <= '9') ||
					(color[i] >= 'a' && color[i] <= 'f') ||
					(color[i] >= 'A' && color[i] <= 'F')))
		{
			return (false);
		}
		i++;
	}
	return (true);
}

bool	number_check(const char *str)
{
	int i = 0;

	if (!str || str[0] == '\0')
		return (false);
	if (str[0] == '+' || str[0] == '-')
		i++;
	if (str[i] == '\0')
		return (false);
	while (str[i])
	{
		if (str[i] < '0' || str[i] > '9')
			return (false);
		i++;
	}
	return (true);
}

bool	valid_point(char *token)
{
	char **point;

	if (ft_strchr(token, ','))
	{
		point = ft_split(token, ',');
		if(!point || !number_check(point[0]) || !color_check(point[1]))
			return (ft_free_array(point), false);
	}
	else if (!number_check(token))
		return (false);
	return(true);
}

bool	points_check(char *line)
{
	char	**split;
	int		i;

	i = 0;
	split = ft_split(line, ' ');
	if (!split)
		return (free(line), false);
	while (split[i])
	{
		if (split[i][0] != '\0' && !valid_point(split[i]))
			return (ft_free_array(split), free(line), false);
		i++;
	}
	ft_free_array(split);
	return (true);
}

==> draw.c <==

void	bresenham_algo(mlx_image_t *image, t_point2d a, t_point2d b)
{
	int			error[2];
	t_point2d	cur;

	cur.x = a.x;
	cur.y = a.y;
	error[0] = abs(b.x - a.x) - abs(b.y - a.y);
	while (cur.x != b.x || cur.y != b.y)
	{
		if ((uint32_t)cur.x < image->width && (uint32_t)cur.y < image->height)
			mlx_put_pixel(image, cur.x, cur.y, get_color(cur, a, b));
		error[1] = 2 * error[0];
		if (error[1] > -abs(b.y - a.y))
		{
			error[0] -= abs(b.y - a.y);
			cur.x += (a.x < b.x);
			cur.x -= (b.x < a.x);
		}
		if (error[1] > -abs(b.x - a.x))
		{
			error[0] -= abs(b.x - a.x);
			cur.y += (a.y < b.y);
			cur.y -= (b.y < a.y);
		}
	}
}

void	project_point(t_map *map, int y, int x)
{
	t_point3d	*previous;
	t_point3d	tmp;
	t_point2d	*new;

	previous = &(map->grid3d[y][x]);
	new = &(map->grid2d[y][x]);
	tmp.x = previous->x;
	tmp.y = previous->y;
	tmp.z = previous->z * map->zscale;
	rotate_z(&tmp.x, &tmp.y, map->zrotate);
	rotate_x(&tmp.y, &tmp.z, map->xrotate);
	rotate_y(&tmp.x, &tmp.z, map->yrotate);
	new->x = (int)((tmp.x * map->zoom - tmp.y * map->zoom) * cos(map->alpha) + map->x_offset);
	new->y = (int)(-tmp.z * map->zoom + (tmp.x * map->zoom + tmp.y * map->zoom) * sin(map->beta) + map->y_offset);
	if (map->use_zcolor)
		new->rgba = previous->zcolor;
	else
		new->rgba = previous->mapcolor;
}

void	draw_line(t_fdf *fdf, int x, int y)
{
	if (y == 0 && x == 0)
		project_point(fdf->map, y, x);
	if (y + 1 < fdf->map->rows)
	{
		project_point(fdf->map, y + 1, x);
		bresenham_algo(fdf->image, fdf->map->grid2d[y][x], fdf->map->grid2d[y + 1][x]);
	}
	if (x + 1 < fdf->map->cols)
	{
		if (y == 0)
			project_point(fdf->map, y, x + 1);
		bresenham_algo(fdf->image, fdf->map->grid2d[y][x], fdf->map->grid2d[y][x + 1]);
	}
}

void	draw_image(void *param)
{
	int		i;
	int		j;
	t_fdf	*fdf;

	fdf = (t_fdf *)param;
	reset_draw(fdf->image);
	i = 0;
	while (i < fdf->map->rows)
	{
		j = 0;
		while (j < fdf->map->cols)
		{
			draw_line(fdf, j, i);
		j++;
		}
		i++;
	}
}

void	display_menu(mlx_t *mlx)
{
	int		x;
	int		y;

	x = 20;
	y = 20;
	mlx_put_string(mlx, "CONTROLS", x, y);
	mlx_put_string(mlx, "Colour\t\t\t\t\t\t\t\tc", x, y += 35);
	mlx_put_string(mlx, "Zoom\t\t\t\t\t\t\t\t\t\tmouse scroll or -+", x, y += 20);
	mlx_put_string(mlx, "Translate\t\t\t\t\tarrow keys", x, y += 20);
	mlx_put_string(mlx, "Scale z\t\t\t\t\t\t\ts + </>", x, y += 20);
	mlx_put_string(mlx, "Rotate x\t\t\t\t\t\tx + </>", x, y += 20);
	mlx_put_string(mlx, "Rotate y\t\t\t\t\t\tc + </>", x, y += 20);
	mlx_put_string(mlx, "Rotate z\t\t\t\t\t\tz + </>", x, y += 20);
	mlx_put_string(mlx, "PROJECTION", x, y += 30);
	mlx_put_string(mlx, "Angle x\t\t\t\t\t\t\tq + </>", x, y += 25);
	mlx_put_string(mlx, "Angle y\t\t\t\t\t\t\tw + </>", x, y += 20);
	mlx_put_string(mlx, "Isometric\t\t\t\t\t1", x, y += 20);
	mlx_put_string(mlx, "Dimetric\t\t\t\t\t\t2", x, y += 20);
	mlx_put_string(mlx, "Trimetric\t\t\t\t\t3", x, y += 20);
	mlx_put_string(mlx, "RESET\t\t\t\t\t\t\t\t\t0", x, y += 30);
}

==> hooks.c <==

void	ft_scroll_hook(double xdelta, double ydelta, void *param)
{
	t_fdf		*fdf;

	fdf = (t_fdf *)param;
	if (ydelta > 0)
		fdf->map->zoom *= 1.02;
	else if (ydelta < 0 && fdf->map->zoom * 0.98 > 0)
		fdf->map->zoom *= 0.98;
	xdelta++;
}

void	ft_hook(void *param)
{
	t_fdf	*fdf;

	fdf = (t_fdf *)param;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_0))
		reset_map(fdf->map);
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_ESCAPE))
		mlx_close_window(fdf->mlx);
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_LEFT))
		fdf->map->x_offset -= 5;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_RIGHT))
		fdf->map->x_offset += 5; 
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_DOWN))
		fdf->map->y_offset += 5;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_UP))
		fdf->map->y_offset -= 5;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_EQUAL))
		ft_scroll_hook(0, 1, param);
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_MINUS))
		ft_scroll_hook(0, -1, param);
}

void	ft_hook_rotate(void *param)
{
	t_fdf	*fdf;
	double	sign;

	fdf = (t_fdf *) param;
	sign = 0;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_COMMA))
		sign = -1;
	else if (mlx_is_key_down(fdf->mlx, MLX_KEY_PERIOD))
		sign = 1;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_Q))
		fdf->map->alpha += sign * 0.02; 
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_W))
		fdf->map->beta += sign * 0.02;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_S))
		fdf->map->zscale += sign * 0.02;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_X))
		fdf->map->xrotate += sign * 0.02;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_Y))
		fdf->map->yrotate += sign * 0.02;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_Z))
		fdf->map->zrotate += sign * 0.02;
}

void	ft_hook_project(void *param)
{
	t_fdf	*fdf;

	fdf = (t_fdf *)param;
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_C))
		fdf->map->use_zcolor = !(fdf->map->use_zcolor);
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_1))
	{
		fdf->map->alpha = 0.523599;
		fdf->map->beta = fdf->map->alpha;
	}
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_2))
	{
		fdf->map->alpha = 0.6370452;
		fdf->map->beta = fdf->map->alpha;
	}
	if (mlx_is_key_down(fdf->mlx, MLX_KEY_3))
	{
		fdf->map->alpha = 0.46373398 / 2;
		fdf->map->beta = 0.46373398;
	}
}

void	resize_hook(int width, int height, void *param)
{
	t_fdf	*fdf;
	float	map_width;
	float	map_height;

	fdf = (t_fdf *) param;
	if(fdf->image)
		mlx_delete_image(fdf->mlx, fdf->image);
	fdf->image = mlx_new_image(fdf->mlx, width, height);
	mlx_image_to_window(fdf->mlx, fdf->image, 0, 0);
	map_width = fdf->map->cols * fdf->map->zoom;
	map_height = fdf->map->rows * fdf->map->zoom;
	fdf->map->x_offset = (width / 2) - (map_width / 2);
	fdf->map->y_offset = (height / 2) - (map_height / 2);
}

==> image.c <==

int	radiant(int begin, int end, double percent)
{
	return((int)((1 - percent) * begin + percent * end));
}

double	colormix(int begin, int end, int current)
{
	double	place;
	double	dist;

	place = current - begin;
	dist = end - begin;
	if (dist == 0)
		return (1.0);
	return (place / dist);
}

int	get_color(t_point2d current, t_point2d a, t_point2d b)
{
	int		red;
	int		green;
	int		blue;
	double	percent;

	if(a.rgba == b.rgba)
		return (a.rgba);
	if (abs(b.x - a.x) > abs(b.y - a.y))
		percent = colormix(a.x, b.x, current.x);
	else
		percent = colormix(a.y, b.y, current.y);
	red = radiant((a.rgba >> 24) & 0xFF, (b.rgba >> 24) & 0xFF, percent);
	green = radiant((a.rgba >> 16) & 0xFF, (b.rgba >> 16) & 0xFF, percent);
	blue = radiant((a.rgba >> 8) & 0xFF, (b.rgba >> 8) & 0xFF, percent);
	return ((red << 24) | (green << 16) | blue << 8 | 0xFF);
}

int	colors(double percent)
{
	if (percent < 0.1)
		return (COLOR_ONE);
	else if (percent < 0.2)
		return (COLOR_TWO);
	else if (percent < 0.3)
		return (COLOR_THREE);
	else if (percent < 0.4)
		return (COLOR_FOUR);
	else if (percent < 0.5)
		return (COLOR_FIVE);
	else if (percent < 0.6)
		return (COLOR_SIX);
	else if (percent < 0.7)
		return (COLOR_SEVEN);
	else if (percent < 0.8)
		return (COLOR_EIGHT);
	else if (percent < 0.9)
		return (COLOR_NINE);
	else
		return (COLOR_TEN); 
}

void	set_zcolor(t_map *map)
{
	int		i;
	int		j;
	double	percent;

	i = 0;
	while (i < map->rows)
	{
		j = 0;
		while (j < map->cols)
		{
			percent = colormix(map->low, map->high, map->grid3d[i][j].z);
			map->grid3d[i][j].zcolor = colors(percent);
			j++;
		}
		i++;
	}
}

==> loop.c <==


void	reset_map(t_map *map)
{
	map->alpha = 0.46373398 / 2;
	map->beta = 0.46373398;
	map->xrotate = 0;
	map->yrotate = 0;
	map->zrotate = 0;
	map->x_offset = WIDTH / 2;
	map->y_offset = HEIGHT / 2;
	map->zoom = 1;
	map->zscale = 1;
	map->use_zcolor = false;
}

void	reset_draw(mlx_image_t *image)
{
	uint32_t	i;
	uint32_t	j;

	i = 0;
	while (i < image->height)
	{
		j = 0;
		while (j < image->width)
		{
			mlx_put_pixel(image, j, i, BACKGROUND);
			j++;
		}
		i++;
	}
}

// void	loop_mlx(t_fdf *fdf)
// {
// 	if(mlx_image_to_window(fdf->mlx, fdf->image, 0, 0) == -1)
// 	{
// 		free_map(fdf->map);
// 		mlx_close_window(fdf->mlx);
// 		// ft_error(mlx_strerror(mlx_errno));
// 		ft_error("error image");
// 	}
// 	mlx_loop_hook(fdf->mlx, &ft_hook, fdf);
// 	mlx_loop_hook(fdf->mlx, &ft_hook_rotate, fdf);
// 	mlx_loop_hook(fdf->mlx, &ft_hook_project, fdf);
// 	mlx_scroll_hook(fdf->mlx, &ft_scroll_hook, fdf);
// 	mlx_loop(fdf->mlx);
// 	mlx_delete_image(fdf->mlx, fdf->image);
// 	mlx_terminate(fdf->mlx);
// }

==> main.c <==

void	grid_check(int fd, t_map *map)
{
	char	*line;
	char	*tmp;
	int		current_column;

	current_column = 0;
	while((tmp = get_next_line(fd)))
	{
		line = ft_strtrim(tmp, "\n");
		free(tmp);
		if (!points_check(line))
			ft_error_close("Invalid point.", fd);
		map->rows++;
		current_column = count_tokens(line, ' ');
		if (map->cols== 0)
			map->cols= current_column;
		else if ((map->cols!= current_column))
		{
			free(line);
			ft_error_close("Couldn't read file", fd);
		}
		free(line);
	}
	ft_printf("**grid_check**\ncol: %d rows: %d\n", map->cols, map->rows); // TESTING:
	return ;
}

void	init_map(t_map *map)
{
	map->alpha = 0.46373398 / 2; // Rotation angle
	map->beta = 0.46373398;
	map->xrotate = 0;
	map->yrotate = 0;
	map->zrotate = 0;
	map->x_offset = WIDTH / 2;  // For centering the image
	map->y_offset = HEIGHT / 2; // For centering the image
	map->zoom = 1; // Zoom factor
	map->zscale = 1; // Scale the z axis for depth or elevation
	map->use_zcolor = false;
	map->high = INT_MIN; // tracks the highest z_value
	map->low = INT_MAX; // tracks the lowest z_value
	map->rows = 0;
	map->cols = 0;
	map->grid2d = NULL;
	map->grid3d = NULL;
}

t_map	*open_validate_map(char *filename)
{
	int		fd;
	t_map	*map;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		ft_error("Can't open file.");
	map = malloc(sizeof(t_map));
	if (!map)
		ft_error_close("Cannot malloc for map.", fd);
	init_map(map);
	grid_check(fd, map);  // checkar free map em caso de erro
	close(fd);
	allocate_grid(map); //TODO:
						// map->interval = ft_min(WIDTH / map->cols, HEIGHT / map->rows) / 2;
						// map->interval = ft_max(2, map->interval);
	fd = open(filename, O_RDONLY);
	if (fd < 0)
		ft_error("Can't re-open file.");
	parse_map(fd, map);
	close(fd);
	set_zcolor(map);
	return (map);
}

void	init_fdf(char *filename, t_fdf	*fdf)
{
	fdf->map = open_validate_map(filename);
	fdf->mlx = mlx_init(WIDTH, HEIGHT, TITLE, true);
	if (!fdf->mlx)
	{
		free_map(fdf->map);
		ft_error("Error: fdf.mlx");
	}
	fdf->image = mlx_new_image(fdf->mlx, WIDTH, HEIGHT);
	if (!fdf->image)
	{
		free_map(fdf->map);
		mlx_close_window(fdf->mlx);
		ft_error("Error: fdf.image");
	}
}

int	main(int argc, char **argv)
{

	t_fdf	fdf;

	if (argc != 2 || !ft_strnstr(argv[1], ".fdf", ft_strlen(argv[1])))
		ft_error("Correct usage: ./fdf <map_name>.fdf");
	ft_bzero(&fdf, sizeof(fdf));
	init_fdf(argv[1], &fdf);
	display_menu(fdf.mlx);
	draw_image(&fdf);
	if(mlx_image_to_window(fdf.mlx, fdf.image, 0, 0) == -1)
	{
		free_map(fdf.map);
		mlx_close_window(fdf.mlx);
		ft_error("error image");
	}
	mlx_loop_hook(fdf.mlx, &ft_hook, &fdf);
	mlx_loop_hook(fdf.mlx, &ft_hook_rotate, &fdf);
	mlx_loop_hook(fdf.mlx, &ft_hook_project, &fdf);
	mlx_scroll_hook(fdf.mlx, &ft_scroll_hook, &fdf);
	mlx_loop_hook(fdf.mlx, &draw_image, &fdf);
	mlx_loop(fdf.mlx);
	mlx_terminate(fdf.mlx);
	free_map(fdf.map);
	return (EXIT_SUCCESS);
}

==> parsing.c <==

int	fill_color(char *data, t_map *map, int fd)
{
	int	color;

	while (*data == '-')
		data++;
	while (ft_isdigit (*data))
		data++;
	if (*data == ',')
		data++;
	else
		return (0xFFFFFFFF);
	if (ft_strncmp(data, "0X", 2) && ft_strncmp(data, "0x", 2))
		ft_error_map("Invalid_map", fd, map);
	data += 2;
	ft_striteri(data, &ft_upper);
	color = ft_atoi_base(data, "0123456789ABCDEF") << 8 | 0xFF;
	return (color);
}

void	process_points(int fd, t_map *map, char *line, int i)
{
	// t_point3d	*point;
	// int			x_offet;
	// int			y_offset;
	int			j;
	char		**split;

	split = ft_split(line, ' ');
	free(line);
	if (!split)
		ft_error_map("split error.", fd, map);
	j = 0;
	while (j < map->cols)
	{
		map->grid3d[i][j].x = (double)j;
		map->grid3d[i][j].y = (double)i;
		map->grid3d[i][j].z = (double)ft_atoi(split[j]);
		map->grid3d[i][j].mapcolor = fill_color(split[j], map, fd);
		map->high = ft_max(map->high, map->grid3d[i][j].z);
		map->low = ft_min(map->low, map->grid3d[i][j].z);
		// printf("x: %f y: %f z: %f color: %d\n", map->grid3d[i][j].x, map->grid3d[i][j].y, map->grid3d[i][j].z, map->grid3d[i][j].mapcolor); // TESTING:
																									  // printf("z: %f color: %d\n", point->z, point->mapcolor);
		j++;
	}
	ft_free_array(split);
}

void	parse_map(int fd, t_map *map)
{
	char	*line;
	char	*tmp;
	// char	**split;
	int		y;

	y = 0;
	while (y < map->rows)
	{
		tmp = get_next_line(fd);
		if (!tmp)
			ft_error_map("Gnl error.", fd, map);
		line = ft_strtrim(tmp,"\n");
		free(tmp);
		// if (!line)
		// 	ft_error_map("ft_strtrim error.", fd, map);
		// ft_printf("line: %s\n", line); // TESTING: OK
		process_points(fd, map, line, y);
		y++;
	}
	ft_printf("parse_map\n"); // TESTING:
}

void	allocate_grid(t_map *map)
{
	int	i;

	map->grid3d = malloc(sizeof(t_point3d) * map->rows);
	map->grid2d = malloc(sizeof(t_point2d) * map->rows);
	// printf("rows: %d\n", map->rows); // TESTING:
	if (!(map->grid2d) || !(map->grid3d))
	{
		free_map(map);
		ft_error("Error malloc grid.");
	}
	i = -1;
	while (++i < map->rows)
	{
		map->grid3d[i] = malloc(sizeof(t_point3d) * map->cols);
		map->grid2d[i] = malloc(sizeof(t_point2d) * map->cols);
		// printf("cols: %d\n", map->cols); // TESTING:
		if (!(map->grid2d[i]) || !(map->grid3d[i]))
		{
			if (i + 1 < map->rows)
			{
				map->grid2d[i + 1] = NULL;
				map->grid3d[i + 1] = NULL;
			}
			free_map(map);
			ft_error("Error malloc grid.");
		}
	}
	ft_printf("allocate_grid\n"); // TESTING:
}

==> rotations.c <==

void	rotate_x(double *y, double *z, double alpha)
{
	double	previous_y;

	previous_y = *y;
	*y = previous_y * cos(alpha) + *z * sin(alpha);
	*z = -previous_y * sin(alpha) + *z * cos(alpha);
}

void	rotate_y(double *x, double *z, double beta)
{
	double	previous_x;

	previous_x = *x;
	*x = previous_x * cos(beta) + *z * sin(beta);
	*z = -previous_x * sin(beta) + *z * cos(beta);
}

void	rotate_z(double *x, double *y, double gamma)
{
	double	previous_x;
	double	previous_y;

	previous_x = *x;
	previous_y = *y;
	*x = previous_x * cos(gamma) - previous_y * sin(gamma);
	*y = previous_x * sin(gamma) + previous_y * cos(gamma);
}

==> utils.c <==

// Exit the program as failure.
void ft_error(char *str)
{
	ft_printf("Error: %s\n", str);
	exit(EXIT_FAILURE);
}

void	ft_free_tab(void **tab, size_t len)
{
	size_t	i;

	i = 0;
	while (i < len && tab[i] != NULL)
	{
		free(tab[i]);
		i++;
	}
	free(tab);
}

void	free_map(t_map *map)
{
	if (!map)
		return ;
	if (map->grid2d)
		ft_free_tab((void **)map->grid2d, map->rows);
	if (map->grid3d)
		ft_free_tab((void **)map->grid3d, map->rows);
	free(map);
}

void ft_error_close(char *str, int fd)
{
	ft_printf("Error: %s\n", str);
	close(fd);
	exit(EXIT_FAILURE);
}

void ft_error_map(char *str, int fd, t_map *map)
{
	ft_printf("Error: %s\n", str);
	close(fd);
	free_map(map);
	exit(EXIT_FAILURE);
}

void	ft_upper(unsigned int i, char *c)
{
	i++;
	*c = ft_toupper(*c);
}
